From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ProstoyArtemka <ProstoyArtemka@yandex.ru>
Date: Tue, 2 Jan 2024 21:51:40 +0700
Subject: [PATCH] URA POBEDA


diff --git a/src/main/java/io/papermc/paper/threadedregions/scheduler/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/scheduler/EntityScheduler.java
index 9f69e189be8202a0ab1450540f5d12187ba6c987..99e9e20ae01f9b4b8cde585d29c57e27c53c996e 100644
--- a/src/main/java/io/papermc/paper/threadedregions/scheduler/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/scheduler/EntityScheduler.java
@@ -61,7 +61,7 @@ public interface EntityScheduler {
      * @return The {@link ScheduledTask} that represents the scheduled task, or {@code null} if the entity has been removed.
      */
     @Nullable ScheduledTask run(@NotNull Plugin plugin, @NotNull Consumer<ScheduledTask> task,
-                                       @Nullable Runnable retired);
+                                @Nullable Runnable retired);
 
     /**
      * Schedules a task with the given delay. If the task failed to schedule because the scheduler is retired (entity
@@ -80,7 +80,7 @@ public interface EntityScheduler {
      * @return The {@link ScheduledTask} that represents the scheduled task, or {@code null} if the entity has been removed.
      */
     @Nullable ScheduledTask runDelayed(@NotNull Plugin plugin, @NotNull Consumer<ScheduledTask> task,
-                                              @Nullable Runnable retired, long delayTicks);
+                                       @Nullable Runnable retired, long delayTicks);
 
     /**
      * Schedules a repeating task with the given delay and period. If the task failed to schedule because the scheduler
@@ -100,5 +100,5 @@ public interface EntityScheduler {
      * @return The {@link ScheduledTask} that represents the scheduled task, or {@code null} if the entity has been removed.
      */
     @Nullable ScheduledTask runAtFixedRate(@NotNull Plugin plugin, @NotNull Consumer<ScheduledTask> task,
-                                                  @Nullable Runnable retired, long initialDelayTicks, long periodTicks);
+                                           @Nullable Runnable retired, long initialDelayTicks, long periodTicks);
 }
diff --git a/src/main/java/org/bukkit/block/Block.java b/src/main/java/org/bukkit/block/Block.java
index 49974558799830d827f9ccd65a8bafee3fb0376b..eef6cbde407e10ca5bc71976d56cb7e9ea91b42e 100644
--- a/src/main/java/org/bukkit/block/Block.java
+++ b/src/main/java/org/bukkit/block/Block.java
@@ -10,9 +10,11 @@ import org.bukkit.World;
 import org.bukkit.block.data.Bisected;
 import org.bukkit.block.data.BlockData;
 import org.bukkit.entity.Entity;
+import org.bukkit.entity.ItemDisplay;
 import org.bukkit.entity.Player;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.metadata.Metadatable;
+import org.bukkit.persistence.PersistentDataType;
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
@@ -20,6 +22,8 @@ import org.bukkit.util.VoxelShape;
 import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.ospaindustries.block.CustomBlock;
+import org.ospaindustries.block.CustomBlockBehavior;
 
 /**
  * Represents a block. This is a live object, and only one Block may exist for
@@ -787,4 +791,18 @@ public interface Block extends Metadatable, Translatable, net.kyori.adventure.tr
         return this.getBlockData().getDestroySpeed(itemStack, considerEnchants);
     }
     // Paper end - destroy speed API
+
+    default boolean isCustom() {
+        return getLocation().getNearbyEntitiesByType(ItemDisplay.class, 1).stream()
+            .filter(d -> d.getPersistentDataContainer().has(CustomBlock.BLOCK_POSITION_KEY))
+            .filter(d -> d.getPersistentDataContainer().get(CustomBlock.BLOCK_POSITION_KEY, PersistentDataType.STRING).equals(Location.locationToString(getLocation())))
+            .toList().size() > 0;
+    }
+
+    @Nullable
+    default CustomBlock toCustom() {
+        if (!isCustom()) return null;
+
+        return CustomBlock.fromBlock(this);
+    }
 }
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 1d0fd7ff8449f815a7d980af0b378181ea8bf8d8..5ed3546b75f6e0a66333db52b56057d203ecd2c7 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -24,12 +24,11 @@ import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.ospaindustries.entity.CustomEntity;
+import org.ospaindustries.entity.CustomEntityBuilder;
 
 /**
  * Represents a base entity in the world
- * <p>
- * Not all methods are guaranteed to work/may have side effects when
- * {@link #isInWorld()} is false.
  */
 public interface Entity extends Metadatable, CommandSender, Nameable, PersistentDataHolder, net.kyori.adventure.text.event.HoverEventSource<net.kyori.adventure.text.event.HoverEvent.ShowEntity>, net.kyori.adventure.sound.Sound.Emitter { // Paper
 
@@ -137,6 +136,7 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      * @param teleportFlags Flags to be used in this teleportation
      * @return <code>true</code> if the teleport was successful
      */
+    @org.jetbrains.annotations.ApiStatus.Experimental
     default boolean teleport(@NotNull Location location, @NotNull io.papermc.paper.entity.TeleportFlag @NotNull... teleportFlags) {
         return this.teleport(location, TeleportCause.PLUGIN, teleportFlags);
     }
@@ -149,6 +149,7 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      * @param teleportFlags Flags to be used in this teleportation
      * @return <code>true</code> if the teleport was successful
      */
+    @org.jetbrains.annotations.ApiStatus.Experimental
     boolean teleport(@NotNull Location location, @NotNull TeleportCause cause, @NotNull io.papermc.paper.entity.TeleportFlag @NotNull... teleportFlags);
     // Paper end - Teleport API
 
@@ -327,8 +328,6 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
 
     /**
      * Mark the entity's removal.
-     *
-     * @throws UnsupportedOperationException if you try to remove a {@link Player} use {@link Player#kickPlayer(String)} in this case instead
      */
     public void remove();
 
@@ -340,8 +339,8 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
     public boolean isDead();
 
     /**
-     * Returns false if the entity has died, been despawned for some other
-     * reason, or has not been added to the world.
+     * Returns false if the entity has died or been despawned for some other
+     * reason.
      *
      * @return True if valid.
      */
@@ -845,45 +844,6 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
     @NotNull
     SpawnCategory getSpawnCategory();
 
-    /**
-     * Checks if this entity has been spawned in a world. <br>
-     * Entities not spawned in a world will not tick, be sent to players, or be
-     * saved to the server files.
-     *
-     * @return whether the entity has been spawned in a world
-     */
-    boolean isInWorld();
-
-    /**
-     * Crates an {@link EntitySnapshot} representing the current state of this entity.
-     *
-     * @return a snapshot representing this entity or null if one cannot be made
-     */
-    @Nullable
-    @ApiStatus.Experimental
-    EntitySnapshot createSnapshot();
-
-    /**
-     * Creates a copy of this entity and all its data. Does not spawn the copy in
-     * the world. <br>
-     * <b>Note:</b> Players cannot be copied.
-     *
-     * @return a copy of this entity.
-     */
-    @NotNull
-    @ApiStatus.Experimental
-    Entity copy();
-
-    /**
-     * Creates a copy of this entity and all its data. Spawns the copy at the given location. <br>
-     * <b>Note:</b> Players cannot be copied.
-     * @param to the location to copy to
-     * @return a copy of this entity.
-     */
-    @NotNull
-    @ApiStatus.Experimental
-    Entity copy(@NotNull Location to);
-
     // Spigot start
     public class Spigot extends CommandSender.Spigot {
 
@@ -1107,4 +1067,15 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      */
     @NotNull String getScoreboardEntryName();
     // Paper end - entity scoreboard name
+
+    default boolean isCustom() {
+        if (getPersistentDataContainer().isEmpty()) return false;
+
+        return toCustom() != null;
+    }
+
+    @Nullable
+    default CustomEntity toCustom() {
+        return CustomEntity.fromEntity(this);
+    }
 }
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index 36e3fbc727cd748aa138f52976154ba32954cd87..8346c155a570edf6853390632b66f14e89b94cae 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -15,8 +15,10 @@ import org.bukkit.enchantments.Enchantment;
 import org.bukkit.inventory.meta.Damageable;
 import org.bukkit.inventory.meta.ItemMeta;
 import org.bukkit.material.MaterialData;
+import org.bukkit.persistence.PersistentDataType;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.ospaindustries.item.CustomItem;
 
 /**
  * Represents a stack of items.
@@ -295,7 +297,7 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
             return true;
         }
         Material comparisonType = (this.type.isLegacy()) ? Bukkit.getUnsafe().fromLegacy(this.getData(), true) : this.type; // This may be called from legacy item stacks, try to get the right material
-        return comparisonType == stack.getType() && /* getDurability() == stack.getDurability() && */hasItemMeta() == stack.hasItemMeta() && (hasItemMeta() ? Bukkit.getItemFactory().equals(getItemMeta(), stack.getItemMeta()) : true); // Paper - remove redundant item durability check
+        return comparisonType == stack.getType() && getDurability() == stack.getDurability() && hasItemMeta() == stack.hasItemMeta() && (hasItemMeta() ? Bukkit.getItemFactory().equals(getItemMeta(), stack.getItemMeta()) : true);
     }
 
     @NotNull
@@ -1005,4 +1007,22 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
         return type.isAir() || amount <= 0;
     }
     // Paper end
+
+    @Nullable
+    public CustomItem toCustomItem(){
+        if(!isCustom()) return null;
+        String tag = getItemMeta().getPersistentDataContainer().get(CustomItem.DICE_CORE_CUSTOM_ITEM_KEY, PersistentDataType.STRING);
+
+        CustomItem customItem = CustomItem.getRegisteredItems().get(tag).clone();
+        customItem.setItemMeta(getItemMeta());
+        return customItem;
+    }
+
+    public boolean isCustom(){
+        if(getItemMeta() == null) return false;
+        String tag = getItemMeta().getPersistentDataContainer().get(CustomItem.DICE_CORE_CUSTOM_ITEM_KEY, PersistentDataType.STRING);
+        if(tag == null) return false;
+        return CustomItem.getRegisteredItems().containsKey(tag);
+    }
+
 }
diff --git a/src/main/java/org/ospaindustries/block/CustomBlock.java b/src/main/java/org/ospaindustries/block/CustomBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd5c6fca9798a5d65499d0b7d987e2b8331622f3
--- /dev/null
+++ b/src/main/java/org/ospaindustries/block/CustomBlock.java
@@ -0,0 +1,203 @@
+package org.ospaindustries.block;
+
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Particle;
+import org.bukkit.block.Block;
+import org.bukkit.entity.ItemDisplay;
+import org.bukkit.entity.Player;
+import org.bukkit.event.block.BlockBreakEvent;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.bukkit.persistence.PersistentDataType;
+import org.bukkit.util.Transformation;
+import org.jetbrains.annotations.Nullable;
+import org.ospaindustries.item.CustomItem;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.InstrumentMaterial;
+import org.ospaindustries.utils.InstrumentType;
+
+import java.util.HashMap;
+import java.util.Optional;
+
+public class CustomBlock {
+    public static NamespacedKey BLOCK_KEY = new NamespacedKey("dice_core", "block_key");
+    public static NamespacedKey BLOCK_DURABILITY_KEY = new NamespacedKey("dice_core", "block_durability");
+    public static NamespacedKey BLOCK_POSITION_KEY = new NamespacedKey("dice_core", "block_position_key");
+
+    private static final HashMap<String, CustomBlock> registeredBlocks = new HashMap<>();
+
+    private final String tag;
+    private final int customModelData;
+    private final CustomLoot loot;
+    private final int maxDurability;
+    private final CustomBlockBehavior behavior;
+    private final InstrumentType instrumentType;
+    private final InstrumentMaterial instrumentMaterial;
+    private final CustomItem item;
+    private Block block;
+    private ItemDisplay mainDisplay;
+
+    CustomBlock(String tag, int customModelData, CustomLoot loot, CustomBlockBehavior behavior, InstrumentType type, InstrumentMaterial material, int durability, CustomItem item) {
+        this.tag = tag;
+        this.customModelData = customModelData;
+        this.loot = loot;
+        this.behavior = behavior;
+        this.maxDurability = durability;
+        this.instrumentType = type;
+        this.instrumentMaterial = material;
+        this.item = item;
+    }
+
+    @Nullable
+    public CustomItem getBlockCustomItem() {
+        return CustomItem.getRegisteredItems().getOrDefault(tag + "_blockitem", null);
+    }
+
+    public void spawnDamageParticle() {
+        Location location = block.getLocation().toCenterLocation();
+
+        location.getWorld().spawnParticle(Particle.ITEM_CRACK, location, 1,
+            0.3, 0.3, 0.3, 0.05, getDisplayItemStack());
+    }
+
+    public void spawnBreakParticle() {
+        Location location = block.getLocation().toCenterLocation();
+
+        location.getWorld().spawnParticle(Particle.ITEM_CRACK, location, 30,
+            0, 0, 0, 0.08, getDisplayItemStack());
+    }
+
+    private ItemStack getDisplayItemStack() {
+        CustomBlock item = this;
+        ItemStack result = new ItemStack(Material.PRISMARINE_CRYSTALS);
+        ItemMeta meta = result.getItemMeta();
+
+        meta.setCustomModelData(item.customModelData);
+        PersistentDataContainer dataContainer = meta.getPersistentDataContainer();
+        dataContainer.set(BLOCK_KEY, PersistentDataType.STRING, item.tag);
+        result.setItemMeta(meta);
+
+        return result;
+    }
+
+    public String getTag() {
+        return tag;
+    }
+
+    public int getCustomModelData() {
+        return customModelData;
+    }
+
+    public CustomBlockBehavior getBehavior() {
+        return behavior;
+    }
+
+    @Nullable
+    public Block getBlock() {
+        return block;
+    }
+
+    public static HashMap<String, CustomBlock> getRegisteredBlocks() {
+        return registeredBlocks;
+    }
+
+    public InstrumentMaterial getInstrumentMaterial() {
+        return instrumentMaterial;
+    }
+
+    public InstrumentType getInstrumentType() {
+        return instrumentType;
+    }
+
+    public CustomLoot getLoot() {
+        return loot;
+    }
+
+    public ItemDisplay getMainDisplay() {
+        return mainDisplay;
+    }
+
+    public int getMaxDurability() {
+        return maxDurability;
+    }
+
+    public int getDurability() {
+        if (mainDisplay == null) return -1;
+
+        return mainDisplay.getPersistentDataContainer().get(BLOCK_DURABILITY_KEY, PersistentDataType.INTEGER);
+    }
+
+    public void setDurability(int durability) {
+        if (mainDisplay == null) return;
+
+        mainDisplay.getPersistentDataContainer().set(BLOCK_DURABILITY_KEY, PersistentDataType.INTEGER, durability);
+    }
+
+    public boolean exist() {
+        return block != null;
+    }
+
+    public CustomBlock place(Location location) {
+        CustomBlock result = this.clone();
+
+        result.block = location.getBlock();
+        result.mainDisplay = location.getWorld().spawn(location.toCenterLocation(), ItemDisplay.class);
+        Transformation transformation = result.mainDisplay.getTransformation();
+
+        transformation.getScale().set(1.05, 1.05, 1.05);
+        transformation.getTranslation().set(-0.025, -0.025, -0.025);
+
+        result.block.setType(Material.BARRIER);
+        result.mainDisplay.setItemStack(getDisplayItemStack());
+        result.mainDisplay.setTransformation(transformation);
+
+        result.mainDisplay.getPersistentDataContainer().set(BLOCK_DURABILITY_KEY, PersistentDataType.INTEGER, maxDurability);
+        result.mainDisplay.getPersistentDataContainer().set(BLOCK_POSITION_KEY, PersistentDataType.STRING, Location.locationToString(result.block.getLocation()));
+        result.mainDisplay.getPersistentDataContainer().set(BLOCK_KEY, PersistentDataType.STRING, tag);
+
+        return result;
+    }
+
+    public void breakBlock(boolean dropLoot, @Nullable Player player) {
+        BlockBreakEvent event = new BlockBreakEvent(block, player);
+        getBehavior().blockBreak(event);
+
+        if (dropLoot)
+            for (ItemStack stack : loot.getLoot())
+                block.getWorld().dropItemNaturally(block.getLocation().toCenterLocation(), stack);
+
+        block.setType(Material.AIR);
+        mainDisplay.remove();
+
+        mainDisplay = null;
+        block = null;
+    }
+
+    @Nullable
+    public static CustomBlock fromBlock(Block block) {
+        Location location = block.getLocation();
+
+        Optional<ItemDisplay> displayOptional = location.getNearbyEntitiesByType(ItemDisplay.class, 1).stream()
+            .filter(display -> display.getPersistentDataContainer().has(CustomBlock.BLOCK_POSITION_KEY, PersistentDataType.STRING))
+            .filter(display -> display.getPersistentDataContainer().get(CustomBlock.BLOCK_POSITION_KEY, PersistentDataType.STRING).equals(Location.locationToString(location))).findAny();
+
+        if (displayOptional.isEmpty()) return null;
+
+        ItemDisplay display = displayOptional.get();
+        String tag = display.getPersistentDataContainer().get(BLOCK_KEY, PersistentDataType.STRING);
+
+        CustomBlock customBlock = getRegisteredBlocks().get(tag).clone();
+        customBlock.block = block;
+        customBlock.mainDisplay = display;
+
+        return customBlock;
+    }
+
+    @Override
+    public CustomBlock clone() {
+        return new CustomBlock(tag, customModelData, loot, behavior, instrumentType, instrumentMaterial, maxDurability, item);
+    }
+}
diff --git a/src/main/java/org/ospaindustries/block/CustomBlockBehavior.java b/src/main/java/org/ospaindustries/block/CustomBlockBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..a142b6c48465b4d629ca8a0ce0b14e77b6e59dfd
--- /dev/null
+++ b/src/main/java/org/ospaindustries/block/CustomBlockBehavior.java
@@ -0,0 +1,15 @@
+package org.ospaindustries.block;
+
+import org.bukkit.event.block.BlockBreakEvent;
+import org.bukkit.event.block.BlockDamageAbortEvent;
+import org.bukkit.event.block.BlockDamageEvent;
+import org.bukkit.event.player.PlayerInteractEvent;
+
+public interface CustomBlockBehavior {
+
+    default void tick(CustomBlock block) {}
+    default void blockBreak(BlockBreakEvent event) {}
+    default void startBreaking(BlockDamageEvent event) {}
+    default void stopBreaking(BlockDamageAbortEvent event) {}
+    default void interact(PlayerInteractEvent event) {}
+}
diff --git a/src/main/java/org/ospaindustries/block/CustomBlockBuilder.java b/src/main/java/org/ospaindustries/block/CustomBlockBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..07df102bb700af797d014a7e7f1764231cef7b99
--- /dev/null
+++ b/src/main/java/org/ospaindustries/block/CustomBlockBuilder.java
@@ -0,0 +1,116 @@
+package org.ospaindustries.block;
+
+import org.bukkit.Material;
+import org.ospaindustries.item.CustomItem;
+import org.ospaindustries.item.CustomItemBuilder;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.InstrumentMaterial;
+import org.ospaindustries.utils.InstrumentType;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class CustomBlockBuilder {
+
+    private final String tag;
+    private CustomBlockBehavior behavior = new CustomBlockBehavior() {};
+    private int customModelData;
+    private int maxDurability;
+    private CustomLoot customLoot;
+    private InstrumentMaterial material;
+    private InstrumentType type;
+
+    private ArrayList<String> itemLore = new ArrayList<>();
+    private int itemModelData = -1;
+    private String itemDisplayName = "";
+    private Material itemMaterial = Material.BARRIER;
+
+    public CustomBlockBuilder(String tag) {
+        this.tag = tag;
+    }
+
+    public CustomBlockBuilder setBehavior(CustomBlockBehavior behavior) {
+        this.behavior = behavior;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setMaxDurability(int maxDurability) {
+        this.maxDurability = maxDurability;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setInstrument(InstrumentMaterial material, InstrumentType type) {
+        this.material = material;
+        this.type = type;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setCustomModelData(int customModelData) {
+        this.customModelData = customModelData;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setCustomLoot(CustomLoot customLoot) {
+        this.customLoot = customLoot;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setItemDisplayName(String itemDisplayName) {
+        this.itemDisplayName = itemDisplayName;
+
+        return this;
+    }
+
+    public CustomBlockBuilder addItemLore(String lorePart) {
+
+        itemLore.add(lorePart);
+
+        return this;
+    }
+
+    public CustomBlockBuilder addItemLore(String... lorePart) {
+        itemLore.addAll(Arrays.stream(lorePart).toList());
+
+        return this;
+    }
+
+    public CustomBlockBuilder addItemLore(List<String> lorePart) {
+        itemLore.addAll(lorePart);
+
+        return this;
+    }
+
+    public CustomBlockBuilder setItemModelData(int itemModelData) {
+        this.itemModelData = itemModelData;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setItemMaterial(Material itemMaterial) {
+        this.itemMaterial = itemMaterial;
+
+        return this;
+    }
+
+    public void register() {
+        new CustomItemBuilder(tag + "_blockitem", itemMaterial, itemDisplayName)
+            .setCustomModelData(itemModelData)
+            .addLore(itemLore)
+            .setBlockItem(true)
+            .register();
+
+        CustomItem customItem = CustomItem.getRegisteredItems().get(tag + "_blockitem");
+
+        if (CustomBlock.getRegisteredBlocks().containsKey(tag))
+            throw new RuntimeException("Can't register block with tag \"" + tag + "\", this block is already registered.");
+
+        CustomBlock block = new CustomBlock(tag, customModelData, customLoot, behavior, type, material, maxDurability, customItem);
+        CustomBlock.getRegisteredBlocks().put(tag, block);
+    }
+}
diff --git a/src/main/java/org/ospaindustries/entity/CustomEntity.java b/src/main/java/org/ospaindustries/entity/CustomEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..c99b74cdfc7c909cae82cf171a5639e7373b6a71
--- /dev/null
+++ b/src/main/java/org/ospaindustries/entity/CustomEntity.java
@@ -0,0 +1,179 @@
+package org.ospaindustries.entity;
+
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.Display;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Interaction;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.persistence.PersistentDataType;
+import org.bukkit.util.Transformation;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.Nullable;
+import org.joml.Vector2f;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.DisplayBuilder;
+
+import java.util.*;
+
+public class CustomEntity {
+
+    public static NamespacedKey ENTITY_KEY = new NamespacedKey("dice_core", "entity_key");
+
+    private static final HashMap<String, CustomEntity> registeredEntities = new HashMap<>();
+    private final String tag;
+    private final Class<? extends Entity> basedOn;
+    private final CustomEntityBehavior behavior;
+    private final boolean show;
+    private final ArrayList<DisplayBuilder> displays;
+    private final Vector2f hitboxSize;
+    private Interaction hitbox;
+    private CustomLoot loot;
+
+    private Entity entity;
+
+    CustomEntity(String tag, Class<? extends Entity> basedOn, Vector2f hitboxSize, CustomEntityBehavior behavior, boolean show, ArrayList<DisplayBuilder> displays, CustomLoot loot) {
+        this.tag = tag;
+        this.basedOn = basedOn;
+        this.behavior = behavior;
+        this.show = show;
+        this.displays = displays;
+        this.hitboxSize = hitboxSize;
+        this.loot = loot;
+    }
+
+    public void spawn(Location location) {
+        entity = location.getWorld().spawn(location, basedOn);
+
+        for (DisplayBuilder builder : displays) {
+            Display display = builder.get(entity.getLocation());
+
+            entity.addPassenger(display);
+        }
+
+        entity.setVisibleByDefault(show);
+        entity.getPersistentDataContainer().set(ENTITY_KEY, PersistentDataType.STRING, tag);
+
+        hitbox = location.getWorld().spawn(location, Interaction.class);
+
+        hitbox.setInteractionHeight(hitboxSize.get(1));
+        hitbox.setInteractionWidth(hitboxSize.get(0));
+
+        entity.addPassenger(hitbox);
+    }
+
+    @Nullable
+    public Display getAnyDisplayByTag(String tag) {
+        if (!isExist()) return null;
+
+        Optional<Display> optional = entity.getPassengers().stream()
+            .filter(e -> e instanceof Display)
+            .map(e -> (Display) e)
+            .filter(e -> e.getPersistentDataContainer().has(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING))
+            .filter(e -> e.getPersistentDataContainer().get(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING).equals(tag))
+            .findAny();
+
+        if (optional.isEmpty()) return null;
+
+        return optional.get();
+    }
+
+    public List<Display> getAllDisplays() {
+        if (!isExist()) return Collections.emptyList();
+
+        return entity.getPassengers().stream()
+            .filter(e -> e instanceof Display)
+            .map(e -> (Display) e)
+            .toList();
+    }
+
+    public List<Display> getAllDisplaysByTag(String tag) {
+        if (!isExist()) return Collections.emptyList();
+
+        return entity.getPassengers().stream()
+            .filter(e -> e instanceof Display)
+            .map(e -> (Display) e)
+            .filter(e -> e.getPersistentDataContainer().has(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING))
+            .filter(e -> e.getPersistentDataContainer().get(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING).equals(tag))
+            .toList();
+    }
+
+    public CustomEntityBehavior getBehavior() {
+        return behavior;
+    }
+
+    @Nullable
+    public static CustomEntity fromEntity(Entity entity) {
+        if (!entity.getPersistentDataContainer().has(ENTITY_KEY)) return null;
+
+        String tag = entity.getPersistentDataContainer().get(ENTITY_KEY, PersistentDataType.STRING);
+
+        CustomEntity customEntity = CustomEntity.getRegisteredEntities().get(tag).clone();
+        customEntity.entity = entity;
+
+        Optional<Interaction> optionalInteraction = entity.getPassengers().stream().filter(e -> e instanceof Interaction).map(e -> (Interaction) e).findAny();
+
+        if (optionalInteraction.isEmpty()) {
+            Interaction hitbox = entity.getLocation().getWorld().spawn(entity.getLocation(), Interaction.class);
+            entity.addPassenger(hitbox);
+
+            customEntity.hitbox = hitbox;
+        } else
+            customEntity.hitbox = optionalInteraction.get();
+
+        if (entity.getPassengers().size() < customEntity.displays.size()) {
+            for (Entity e : entity.getPassengers())
+                if (!(e instanceof Display)) {
+                    entity.removePassenger(e);
+
+                    e.remove();
+                }
+
+            entity.removePassenger(customEntity.hitbox);
+
+            for (DisplayBuilder builder : customEntity.displays)
+                entity.addPassenger(builder.get(entity.getLocation()));
+        }
+
+        return customEntity;
+    }
+
+    public String getTag() {
+        return tag;
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    public Interaction getHitbox() {
+        return hitbox;
+    }
+
+    private boolean isExist() {
+        return entity != null && !entity.isEmpty() && !entity.isDead() && !entity.isValid();
+    }
+
+    public static HashMap<String, CustomEntity> getRegisteredEntities() {
+        return registeredEntities;
+    }
+
+    @Override
+    public CustomEntity clone() {
+        return new CustomEntity(tag, basedOn, hitboxSize, behavior, show, displays, loot);
+    }
+
+    public void remove(boolean useLoot) {
+        if (hitbox != null) hitbox.remove();
+
+        if (useLoot)
+            for (ItemStack item : loot.getLoot())
+                entity.getWorld().dropItemNaturally(entity.getLocation(), item);
+
+        if (entity != null) {
+            for (Entity e : entity.getPassengers()) e.remove();
+
+            entity.remove();
+        }
+    }
+}
diff --git a/src/main/java/org/ospaindustries/entity/CustomEntityBehavior.java b/src/main/java/org/ospaindustries/entity/CustomEntityBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..86dc488ae9ced495fa974943fde09f5e55889181
--- /dev/null
+++ b/src/main/java/org/ospaindustries/entity/CustomEntityBehavior.java
@@ -0,0 +1,16 @@
+package org.ospaindustries.entity;
+
+import io.papermc.paper.event.player.PrePlayerAttackEntityEvent;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.event.entity.EntityDeathEvent;
+import org.bukkit.event.player.PlayerInteractAtEntityEvent;
+
+public interface CustomEntityBehavior {
+
+    default void tick(CustomEntity entity) {}
+    default void death(EntityDeathEvent event) {}
+    default void damageHitbox(PrePlayerAttackEntityEvent event) {}
+    default void damageEntity(EntityDamageEvent event) {}
+    default void interactionAtHitBox(PlayerInteractAtEntityEvent event) {}
+    default void interactionAtEntity(PlayerInteractAtEntityEvent event) {}
+}
diff --git a/src/main/java/org/ospaindustries/entity/CustomEntityBuilder.java b/src/main/java/org/ospaindustries/entity/CustomEntityBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d5f986fb0d1bbc6f32b28db8fd0edfb4fabd59d
--- /dev/null
+++ b/src/main/java/org/ospaindustries/entity/CustomEntityBuilder.java
@@ -0,0 +1,78 @@
+package org.ospaindustries.entity;
+
+import org.bukkit.entity.EntityType;
+import org.bukkit.inventory.ItemStack;
+import org.joml.Vector2f;
+import org.ospaindustries.block.CustomBlock;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.DisplayBuilder;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class CustomEntityBuilder {
+    private String tag;
+    private EntityType baseOn;
+    private final ArrayList<DisplayBuilder> displays = new ArrayList<>();
+    private CustomEntityBehavior behavior;
+    private boolean showBasedEntity = false;
+    private Vector2f hitbox = new Vector2f(1, 1);
+    private CustomLoot loot = Collections::emptyList;
+
+    public CustomEntityBuilder(String tag, EntityType baseOn) {
+        this.tag = tag;
+        this.baseOn = baseOn;
+    }
+
+    public void setTag(String tag) {
+        this.tag = tag;
+    }
+
+    public void setEntity(EntityType baseOn) {
+        this.baseOn = baseOn;
+    }
+
+    public CustomEntityBuilder addDisplay(DisplayBuilder displayBuilder) {
+        displays.add(displayBuilder);
+
+        return this;
+    }
+
+    public CustomEntityBuilder setBehavior(CustomEntityBehavior behavior) {
+        this.behavior = behavior;
+
+        return this;
+    }
+
+    public CustomEntityBuilder setBasedEntityVisibility(boolean value) {
+        showBasedEntity = value;
+
+        return this;
+     }
+
+     public CustomEntityBuilder setHitBoxSize(Vector2f vector) {
+        hitbox = vector;
+
+        return this;
+    }
+
+    public CustomEntityBuilder setHitBoxSize(float width, float height) {
+        hitbox = new Vector2f(width, height);
+
+        return this;
+    }
+
+    public void setLoot(CustomLoot loot) {
+        this.loot = loot;
+    }
+
+    public void register() {
+        CustomEntity entity = new CustomEntity(tag, baseOn.getEntityClass(), hitbox, behavior, showBasedEntity, displays, loot);
+
+        if (CustomEntity.getRegisteredEntities().containsKey(tag))
+            throw new RuntimeException("Can't register entity with tag \"" + tag + "\", this entity is already registered.");
+
+        CustomEntity.getRegisteredEntities().put(tag, entity);
+    }
+}
diff --git a/src/main/java/org/ospaindustries/item/CustomItem.java b/src/main/java/org/ospaindustries/item/CustomItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..9724b2b982273b223b02f87d93a731c66514807f
--- /dev/null
+++ b/src/main/java/org/ospaindustries/item/CustomItem.java
@@ -0,0 +1,116 @@
+package org.ospaindustries.item;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemFlag;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class CustomItem extends ItemStack {
+
+    public static NamespacedKey DICE_CORE_CUSTOM_ITEM_KEY = new NamespacedKey("dice_core", "custom_item_key");
+    private static final HashMap<String, CustomItem> registeredItems = new HashMap<>();
+    private final String itemTag;
+    private final boolean isBlockItem;
+    private final CustomItemBehavior behavior;
+    private int knockbackBonus;
+    private final boolean isProjectile;
+
+    CustomItem(String name, Material material, String itemTag, int customModelData, double knockbackBonus, ArrayList<String> lore, ArrayList<ItemFlag> flags, HashMap<Attribute, AttributeModifier> attributes, CustomItemBehavior behavior, boolean isBlockItem, boolean isProjectile) {
+        this.itemTag = itemTag;
+        this.behavior = behavior;
+        this.isBlockItem = isBlockItem;
+        this.isProjectile = isProjectile;
+
+        setType(material);
+
+        ItemMeta meta = getItemMeta();
+        meta.setDisplayName(name);
+        meta.setCustomModelData(customModelData);
+        meta.setLore(lore);
+        meta.getPersistentDataContainer().set(CustomItem.DICE_CORE_CUSTOM_ITEM_KEY, PersistentDataType.STRING, itemTag);
+
+        meta.setDisplayName(ChatColor.RESET + meta.getDisplayName());
+
+        for(ItemFlag flag: flags){
+            meta.addItemFlags(flag);
+        }
+        for (Attribute attribute: attributes.keySet()) {
+            meta.addAttributeModifier(attribute, attributes.get(attribute));
+        }
+
+        setItemMeta(meta);
+        setAmount(1);
+    }
+
+    public String getItemTag() {
+        return itemTag;
+    }
+
+    public CustomItemBehavior getBehavior(){
+         return behavior;
+    }
+    public boolean isBlockItem() {
+        return isBlockItem;
+    }
+    public int getKnockbackBonus(){
+         return knockbackBonus;
+     }
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+
+        if (!(obj instanceof CustomItem stack))
+            return false;
+
+        return getAmount() == stack.getAmount() && isSimilar(stack);
+    }
+
+    @Override
+    public boolean isSimilar(@Nullable ItemStack obj) {
+        if (this == obj)
+            return true;
+
+        if (!(obj instanceof CustomItem))
+            return false;
+
+        return getItemTag().equals(this.itemTag);
+    }
+
+    public static HashMap<String, CustomItem> getRegisteredItems() {
+        return registeredItems;
+    }
+
+    @Override
+    public @NotNull CustomItem clone() {
+        CustomItem itemStack = (CustomItem) super.clone();
+
+        if (getItemMeta() != null) {
+            itemStack.setItemMeta(getItemMeta());
+        }
+
+        if (getData() != null) {
+            itemStack.setData(getData());
+        }
+
+        return itemStack;
+    }
+
+    public boolean isProjectile() {
+         return isProjectile;
+    }
+}
diff --git a/src/main/java/org/ospaindustries/item/CustomItemBehavior.java b/src/main/java/org/ospaindustries/item/CustomItemBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..c08f1c76dc3845649f12c58b0548be7a6133ac17
--- /dev/null
+++ b/src/main/java/org/ospaindustries/item/CustomItemBehavior.java
@@ -0,0 +1,16 @@
+package org.ospaindustries.item;
+
+import org.bukkit.event.entity.EntityPickupItemEvent;
+import org.bukkit.event.inventory.InventoryClickEvent;
+import org.bukkit.event.player.*;
+import org.bukkit.inventory.Inventory;
+
+public interface CustomItemBehavior {
+
+    default void onInteract(PlayerInteractEvent e){}
+    default void onInteractAtEntity(PlayerInteractAtEntityEvent e){}
+    default void onInventoryClickWithCustomItem(InventoryClickEvent e){}
+    default void onInventoryClickAtCustomItem(InventoryClickEvent e){}
+    default void onDropItem(PlayerDropItemEvent e){}
+    default void onPickup(EntityPickupItemEvent e){}
+}
diff --git a/src/main/java/org/ospaindustries/item/CustomItemBuilder.java b/src/main/java/org/ospaindustries/item/CustomItemBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3f2ac23ae7ceaa78662544b6431f01f983ce001
--- /dev/null
+++ b/src/main/java/org/ospaindustries/item/CustomItemBuilder.java
@@ -0,0 +1,95 @@
+package org.ospaindustries.item;
+
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.checkerframework.checker.units.qual.A;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class CustomItemBuilder {
+
+    private String displayName;
+    private Material material;
+    private String tag;
+    private int customModelData;
+    private CustomItemBehavior behavior;
+    private ArrayList<String> lore = new ArrayList<>();
+    private boolean isBlockItem = false;
+
+    public CustomItemBuilder(String tag, Material material, String displayName) {
+        this.tag = tag;
+        this.material = material;
+        this.displayName = displayName;
+    }
+
+    public CustomItemBuilder(String tag, Material material) {
+        this.tag = tag;
+        this.material = material;
+    }
+
+    public void register() {
+        NamespacedKey key = new NamespacedKey("dice_core", tag);
+        CustomItem item = new CustomItem(displayName, material, tag, customModelData, lore, behavior, isBlockItem);
+
+        if (CustomItem.getRegisteredItems().containsKey(key))
+            throw new RuntimeException("Can't register item with tag \"" + tag + "\", this item is already registered.");
+
+        CustomItem.getRegisteredItems().put(tag, item);
+    }
+
+    public CustomItemBuilder setTag(String tag) {
+        this.tag = tag;
+
+        return this;
+    }
+
+    public CustomItemBuilder setMaterial(Material material) {
+        this.material = material;
+
+        return this;
+    }
+
+    public CustomItemBuilder setDisplayName(String displayName) {
+        this.displayName = displayName;
+
+        return this;
+    }
+
+    public CustomItemBuilder setCustomModelData(int customModelData) {
+        this.customModelData = customModelData;
+
+        return this;
+    }
+
+    public CustomItemBuilder setCustomItemBehavior(CustomItemBehavior behavior){
+        this.behavior = behavior;
+
+        return this;
+    }
+
+    public CustomItemBuilder setBlockItem(boolean blockItem) {
+        isBlockItem = blockItem;
+
+        return this;
+    }
+
+    public CustomItemBuilder addLore(String lorePart) {
+        lore.add(lorePart);
+
+        return this;
+    }
+
+    public CustomItemBuilder addLore(String... lorePart) {
+        lore.addAll(Arrays.stream(lorePart).toList());
+
+        return this;
+    }
+
+    public CustomItemBuilder addLore(List<String> lorePart) {
+        lore.addAll(lorePart);
+
+        return this;
+    }
+}
diff --git a/src/main/java/org/ospaindustries/utils/BreakBlockRunnable.java b/src/main/java/org/ospaindustries/utils/BreakBlockRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..46accb259aa197dde7e3c1bf3fb2f6600ca18381
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/BreakBlockRunnable.java
@@ -0,0 +1,93 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.Damageable;
+import org.bukkit.scheduler.BukkitRunnable;
+import org.ospaindustries.block.CustomBlock;
+
+import java.util.HashMap;
+
+public class BreakBlockRunnable extends BukkitRunnable {
+
+    public static HashMap<Location, BreakBlockRunnable> breakBlockRunnables = new HashMap<>();
+
+    private final CustomBlock block;
+    private final Player player;
+
+    public BreakBlockRunnable(CustomBlock block, Player player) {
+        this.block = block;
+        this.player = player;
+
+        if (block.getBlock() == null) return;
+
+        breakBlockRunnables.put(block.getBlock().getLocation(), this);
+    }
+
+    private InstrumentMaterial getMaterial(ItemStack itemStack) {
+        String prefix = itemStack.getType().name().split("_")[0];
+        InstrumentMaterial material;
+
+        try {
+            material = InstrumentMaterial.valueOf(prefix);
+        } catch (IllegalArgumentException e) {
+            material = InstrumentMaterial.AIR;
+        }
+
+        return material;
+    }
+
+    private InstrumentType getType(ItemStack itemStack) {
+        InstrumentType type = null;
+
+        for (InstrumentType t : InstrumentType.values())
+            if (itemStack.getType().name().toLowerCase().contains(t.name().toLowerCase())) {
+                type = t;
+
+                break;
+            }
+
+        if (type == null) type = InstrumentType.HAND;
+
+        return type;
+    }
+
+    private int getDamage() {
+        ItemStack playerHand = player.getInventory().getItem(EquipmentSlot.HAND);
+        InstrumentMaterial material = getMaterial(playerHand);
+        InstrumentType type = getType(playerHand);
+
+        if (block.getInstrumentType() != type) return 1;
+
+        return material.getEfficiency();
+    }
+
+    @Override
+    public void run() {
+        block.setDurability(block.getDurability() - getDamage());
+        block.spawnDamageParticle();
+
+        if (block.getDurability() >= 0) return;
+
+        ItemStack stack = player.getInventory().getItem(EquipmentSlot.HAND);
+
+        breakBlockRunnables.remove(block.getBlock().getLocation());
+        this.cancel();
+
+        block.spawnBreakParticle();
+
+        if (getMaterial(stack).ordinal() < block.getInstrumentMaterial().ordinal() || getType(stack) != block.getInstrumentType())
+            block.breakBlock(false, player);
+        else
+            block.breakBlock(true, player);
+
+        if (stack.getItemMeta() instanceof Damageable) {
+            org.bukkit.entity.Damageable damageable = (org.bukkit.entity.Damageable) stack.getItemMeta();
+
+            damageable.damage(1);
+        }
+    }
+}
diff --git a/src/main/java/org/ospaindustries/utils/CustomLoot.java b/src/main/java/org/ospaindustries/utils/CustomLoot.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bed950fb24e22db8b9f8797f973bd31506a127f
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/CustomLoot.java
@@ -0,0 +1,11 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.inventory.ItemStack;
+
+import java.util.List;
+
+public interface CustomLoot {
+
+    List<ItemStack> getLoot();
+
+}
diff --git a/src/main/java/org/ospaindustries/utils/DisplayBuilder.java b/src/main/java/org/ospaindustries/utils/DisplayBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a1c6a63c61c71f45afa5d731aed894aa4ce9d89
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/DisplayBuilder.java
@@ -0,0 +1,11 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.Display;
+
+public interface DisplayBuilder {
+    NamespacedKey DISPLAY_TAG_KEY = new NamespacedKey("dice_core", "display_tag_key");
+
+    Display get(Location location);
+}
diff --git a/src/main/java/org/ospaindustries/utils/InstrumentMaterial.java b/src/main/java/org/ospaindustries/utils/InstrumentMaterial.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8c2952d3d9445eda95219ea1d0848e55cdb4585
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/InstrumentMaterial.java
@@ -0,0 +1,23 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.Material;
+
+public enum InstrumentMaterial {
+    AIR(1),
+    WOODEN(2),
+    STONE(4),
+    GOLDEN(12),
+    IRON(6),
+    DIAMOND(8),
+    NETHERITE(10);
+
+    private final int efficiency;
+
+    InstrumentMaterial(int efficiency) {
+        this.efficiency = efficiency;
+    }
+
+    public int getEfficiency() {
+        return efficiency;
+    }
+}
diff --git a/src/main/java/org/ospaindustries/utils/InstrumentType.java b/src/main/java/org/ospaindustries/utils/InstrumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a92f812e66a26b499fc212c7d5039ea272d6fbf
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/InstrumentType.java
@@ -0,0 +1,11 @@
+package org.ospaindustries.utils;
+
+public enum InstrumentType {
+    HAND,
+    PICKAXE,
+    AXE,
+    SWORD,
+    HOE,
+    SHOVEL,
+    SHEARS
+}
