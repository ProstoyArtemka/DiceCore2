From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ProstoyArtemka <ProstoyArtemka@yandex.ru>
Date: Wed, 3 Jan 2024 18:30:34 +0700
Subject: [PATCH] Release


diff --git a/src/main/java/org/ospaindustries/block/CustomBlock.java b/src/main/java/org/ospaindustries/block/CustomBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ebc277c50aab1c50674fd590a6d4dd1c471af29
--- /dev/null
+++ b/src/main/java/org/ospaindustries/block/CustomBlock.java
@@ -0,0 +1,211 @@
+package org.ospaindustries.block;
+
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Particle;
+import org.bukkit.block.Block;
+import org.bukkit.entity.ItemDisplay;
+import org.bukkit.entity.Player;
+import org.bukkit.event.block.BlockBreakEvent;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.bukkit.persistence.PersistentDataType;
+import org.bukkit.util.Transformation;
+import org.jetbrains.annotations.Nullable;
+import org.ospaindustries.item.CustomItem;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.InstrumentMaterial;
+import org.ospaindustries.utils.InstrumentType;
+
+import java.util.HashMap;
+import java.util.Optional;
+
+public class CustomBlock {
+    public static NamespacedKey BLOCK_KEY = new NamespacedKey("dice_core", "block_key");
+    public static NamespacedKey BLOCK_DURABILITY_KEY = new NamespacedKey("dice_core", "block_durability");
+    public static NamespacedKey BLOCK_POSITION_KEY = new NamespacedKey("dice_core", "block_position_key");
+
+    private static final HashMap<String, CustomBlock> registeredBlocks = new HashMap<>();
+
+    private final String tag;
+    private final int customModelData;
+    private final CustomLoot loot;
+    private final int maxDurability;
+    private final CustomBlockBehavior behavior;
+    private final InstrumentType instrumentType;
+    private final InstrumentMaterial instrumentMaterial;
+    private final CustomItem item;
+    private Block block;
+    private ItemDisplay mainDisplay;
+
+    CustomBlock(String tag, int customModelData, CustomLoot loot, CustomBlockBehavior behavior, InstrumentType type, InstrumentMaterial material, int durability, CustomItem item) {
+        this.tag = tag;
+        this.customModelData = customModelData;
+        this.loot = loot;
+        this.behavior = behavior;
+        this.maxDurability = durability;
+        this.instrumentType = type;
+        this.instrumentMaterial = material;
+        this.item = item;
+    }
+
+    @Nullable
+    public CustomItem getBlockCustomItem() {
+        return CustomItem.getRegisteredItems().getOrDefault(tag + "_blockitem", null);
+    }
+
+    public void spawnDamageParticle() {
+        Location location = block.getLocation().toCenterLocation();
+
+        location.getWorld().spawnParticle(Particle.ITEM_CRACK, location, 1,
+            0.3, 0.3, 0.3, 0.05, getDisplayItemStack());
+    }
+
+    public void spawnBreakParticle() {
+        Location location = block.getLocation().toCenterLocation();
+
+        location.getWorld().spawnParticle(Particle.ITEM_CRACK, location, 30,
+            0, 0, 0, 0.08, getDisplayItemStack());
+    }
+
+    private ItemStack getDisplayItemStack() {
+        CustomBlock item = this;
+        ItemStack result = new ItemStack(Material.PRISMARINE_CRYSTALS);
+        ItemMeta meta = result.getItemMeta();
+
+        meta.setCustomModelData(item.customModelData);
+        PersistentDataContainer dataContainer = meta.getPersistentDataContainer();
+        dataContainer.set(BLOCK_KEY, PersistentDataType.STRING, item.tag);
+        result.setItemMeta(meta);
+
+        return result;
+    }
+
+    public String getTag() {
+        return tag;
+    }
+
+    public int getCustomModelData() {
+        return customModelData;
+    }
+
+    public CustomBlockBehavior getBehavior() {
+        return behavior;
+    }
+
+    @Nullable
+    public Block getBlock() {
+        return block;
+    }
+
+    public static HashMap<String, CustomBlock> getRegisteredBlocks() {
+        return registeredBlocks;
+    }
+
+    public InstrumentMaterial getInstrumentMaterial() {
+        return instrumentMaterial;
+    }
+
+    public InstrumentType getInstrumentType() {
+        return instrumentType;
+    }
+
+    public CustomLoot getLoot() {
+        return loot;
+    }
+
+    public ItemDisplay getMainDisplay() {
+        return mainDisplay;
+    }
+
+    public int getMaxDurability() {
+        return maxDurability;
+    }
+
+    public int getDurability() {
+        if (mainDisplay == null) return -1;
+
+        return mainDisplay.getPersistentDataContainer().get(BLOCK_DURABILITY_KEY, PersistentDataType.INTEGER);
+    }
+
+    public void setDurability(int durability) {
+        if (mainDisplay == null) return;
+
+        mainDisplay.getPersistentDataContainer().set(BLOCK_DURABILITY_KEY, PersistentDataType.INTEGER, durability);
+    }
+
+    public boolean exist() {
+        return block != null;
+    }
+
+    public CustomBlock place(Location location) {
+        CustomBlock result = this.clone();
+
+        result.block = location.getBlock();
+        result.mainDisplay = location.getWorld().spawn(location.toCenterLocation(), ItemDisplay.class);
+        Transformation transformation = result.mainDisplay.getTransformation();
+
+        transformation.getScale().set(1.05, 1.05, 1.05);
+        transformation.getTranslation().set(-0.025, -0.025, -0.025);
+
+        result.block.setType(Material.BARRIER);
+        result.mainDisplay.setItemStack(getDisplayItemStack());
+        result.mainDisplay.setTransformation(transformation);
+
+        result.mainDisplay.getPersistentDataContainer().set(BLOCK_DURABILITY_KEY, PersistentDataType.INTEGER, maxDurability);
+        result.mainDisplay.getPersistentDataContainer().set(BLOCK_POSITION_KEY, PersistentDataType.STRING, Location.locationToString(result.block.getLocation()));
+        result.mainDisplay.getPersistentDataContainer().set(BLOCK_KEY, PersistentDataType.STRING, tag);;
+
+        return result;
+    }
+
+    public void breakBlock(boolean dropLoot, @Nullable Player player) {
+        BlockBreakEvent event = new BlockBreakEvent(block, player);
+        getBehavior().blockBreak(event);
+
+        if (dropLoot)
+            for (ItemStack stack : loot.getLoot())
+                block.getWorld().dropItemNaturally(block.getLocation().toCenterLocation(), stack);
+
+        block.setType(Material.AIR);
+        mainDisplay.remove();
+
+        mainDisplay = null;
+        block = null;
+    }
+
+    @Nullable
+    public static CustomBlock fromBlock(Block block) {
+        Location location = block.getLocation();
+
+        Optional<ItemDisplay> displayOptional = location.getNearbyEntitiesByType(ItemDisplay.class, 1).stream()
+            .filter(display -> display.getPersistentDataContainer().has(CustomBlock.BLOCK_POSITION_KEY, PersistentDataType.STRING))
+            .filter(display -> display.getPersistentDataContainer().get(CustomBlock.BLOCK_POSITION_KEY, PersistentDataType.STRING).equals(Location.locationToString(location))).findAny();
+
+        if (displayOptional.isEmpty()) return null;
+
+        ItemDisplay display = displayOptional.get();
+        String tag = display.getPersistentDataContainer().get(BLOCK_KEY, PersistentDataType.STRING);
+
+        CustomBlock customBlock = getRegisteredBlocks().get(tag).clone();
+        customBlock.block = block;
+        customBlock.mainDisplay = display;
+
+        return customBlock;
+    }
+
+    @Nullable
+    public static CustomBlock fromBlockItem(CustomItem item) {
+        if (!item.isBlockItem()) return null;
+        String tag = item.getItemTag().substring(0, item.getItemTag().length() - "_blockitem".length());
+
+        return CustomBlock.getRegisteredBlocks().getOrDefault(tag, null);
+    }
+
+    @Override
+    public CustomBlock clone() {
+        return new CustomBlock(tag, customModelData, loot, behavior, instrumentType, instrumentMaterial, maxDurability, item);
+    }
+}
diff --git a/src/main/java/org/ospaindustries/block/CustomBlockBehavior.java b/src/main/java/org/ospaindustries/block/CustomBlockBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..97ece015086a7bbaaed06a712778590d057dfe6c
--- /dev/null
+++ b/src/main/java/org/ospaindustries/block/CustomBlockBehavior.java
@@ -0,0 +1,17 @@
+package org.ospaindustries.block;
+
+import org.bukkit.event.block.BlockBreakEvent;
+import org.bukkit.event.block.BlockDamageAbortEvent;
+import org.bukkit.event.block.BlockDamageEvent;
+import org.bukkit.event.block.BlockPlaceEvent;
+import org.bukkit.event.player.PlayerInteractEvent;
+
+public interface CustomBlockBehavior {
+
+    default void tick(CustomBlock block) {}
+    default void blockBreak(BlockBreakEvent event) {}
+    default void startBreaking(BlockDamageEvent event) {}
+    default void stopBreaking(BlockDamageAbortEvent event) {}
+    default void interact(PlayerInteractEvent event) {}
+    default void placeBlock(BlockPlaceEvent event) {}
+}
diff --git a/src/main/java/org/ospaindustries/block/CustomBlockBuilder.java b/src/main/java/org/ospaindustries/block/CustomBlockBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..c515b4337debda387603fca007ba9e4a2a00b31f
--- /dev/null
+++ b/src/main/java/org/ospaindustries/block/CustomBlockBuilder.java
@@ -0,0 +1,116 @@
+package org.ospaindustries.block;
+
+import org.bukkit.Material;
+import org.ospaindustries.item.CustomItem;
+import org.ospaindustries.item.CustomItemBuilder;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.InstrumentMaterial;
+import org.ospaindustries.utils.InstrumentType;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class CustomBlockBuilder {
+
+    private final String tag;
+    private CustomBlockBehavior behavior = new CustomBlockBehavior() {};
+    private int customModelData;
+    private int maxDurability;
+    private CustomLoot customLoot;
+    private InstrumentMaterial material;
+    private InstrumentType type;
+
+    private final ArrayList<String> itemLore = new ArrayList<>();
+    private int itemModelData = -1;
+    private String itemDisplayName = "";
+    private Material itemMaterial = Material.BARRIER;
+
+    public CustomBlockBuilder(String tag) {
+        this.tag = tag;
+    }
+
+    public CustomBlockBuilder setBehavior(CustomBlockBehavior behavior) {
+        this.behavior = behavior;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setMaxDurability(int maxDurability) {
+        this.maxDurability = maxDurability;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setInstrument(InstrumentMaterial material, InstrumentType type) {
+        this.material = material;
+        this.type = type;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setCustomModelData(int customModelData) {
+        this.customModelData = customModelData;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setCustomLoot(CustomLoot customLoot) {
+        this.customLoot = customLoot;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setItemDisplayName(String itemDisplayName) {
+        this.itemDisplayName = itemDisplayName;
+
+        return this;
+    }
+
+    public CustomBlockBuilder addItemLore(String lorePart) {
+
+        itemLore.add(lorePart);
+
+        return this;
+    }
+
+    public CustomBlockBuilder addItemLore(String... lorePart) {
+        itemLore.addAll(Arrays.stream(lorePart).toList());
+
+        return this;
+    }
+
+    public CustomBlockBuilder addItemLore(List<String> lorePart) {
+        itemLore.addAll(lorePart);
+
+        return this;
+    }
+
+    public CustomBlockBuilder setItemModelData(int itemModelData) {
+        this.itemModelData = itemModelData;
+
+        return this;
+    }
+
+    public CustomBlockBuilder setItemMaterial(Material itemMaterial) {
+        this.itemMaterial = itemMaterial;
+
+        return this;
+    }
+
+    public void register() {
+        new CustomItemBuilder(tag + "_blockitem", itemMaterial, itemDisplayName)
+            .setCustomModelData(itemModelData)
+            .addLore(itemLore)
+            .setBlockItem(true)
+            .register();
+
+        CustomItem customItem = CustomItem.getRegisteredItems().get(tag + "_blockitem");
+
+        if (CustomBlock.getRegisteredBlocks().containsKey(tag))
+            throw new RuntimeException("Can't register block with tag \"" + tag + "\", this block is already registered.");
+
+        CustomBlock block = new CustomBlock(tag, customModelData, customLoot, behavior, type, material, maxDurability, customItem);
+        CustomBlock.getRegisteredBlocks().put(tag, block);
+    }
+}
diff --git a/src/main/java/org/ospaindustries/entity/CustomEntity.java b/src/main/java/org/ospaindustries/entity/CustomEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..c99b74cdfc7c909cae82cf171a5639e7373b6a71
--- /dev/null
+++ b/src/main/java/org/ospaindustries/entity/CustomEntity.java
@@ -0,0 +1,179 @@
+package org.ospaindustries.entity;
+
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.Display;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Interaction;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.persistence.PersistentDataType;
+import org.bukkit.util.Transformation;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.Nullable;
+import org.joml.Vector2f;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.DisplayBuilder;
+
+import java.util.*;
+
+public class CustomEntity {
+
+    public static NamespacedKey ENTITY_KEY = new NamespacedKey("dice_core", "entity_key");
+
+    private static final HashMap<String, CustomEntity> registeredEntities = new HashMap<>();
+    private final String tag;
+    private final Class<? extends Entity> basedOn;
+    private final CustomEntityBehavior behavior;
+    private final boolean show;
+    private final ArrayList<DisplayBuilder> displays;
+    private final Vector2f hitboxSize;
+    private Interaction hitbox;
+    private CustomLoot loot;
+
+    private Entity entity;
+
+    CustomEntity(String tag, Class<? extends Entity> basedOn, Vector2f hitboxSize, CustomEntityBehavior behavior, boolean show, ArrayList<DisplayBuilder> displays, CustomLoot loot) {
+        this.tag = tag;
+        this.basedOn = basedOn;
+        this.behavior = behavior;
+        this.show = show;
+        this.displays = displays;
+        this.hitboxSize = hitboxSize;
+        this.loot = loot;
+    }
+
+    public void spawn(Location location) {
+        entity = location.getWorld().spawn(location, basedOn);
+
+        for (DisplayBuilder builder : displays) {
+            Display display = builder.get(entity.getLocation());
+
+            entity.addPassenger(display);
+        }
+
+        entity.setVisibleByDefault(show);
+        entity.getPersistentDataContainer().set(ENTITY_KEY, PersistentDataType.STRING, tag);
+
+        hitbox = location.getWorld().spawn(location, Interaction.class);
+
+        hitbox.setInteractionHeight(hitboxSize.get(1));
+        hitbox.setInteractionWidth(hitboxSize.get(0));
+
+        entity.addPassenger(hitbox);
+    }
+
+    @Nullable
+    public Display getAnyDisplayByTag(String tag) {
+        if (!isExist()) return null;
+
+        Optional<Display> optional = entity.getPassengers().stream()
+            .filter(e -> e instanceof Display)
+            .map(e -> (Display) e)
+            .filter(e -> e.getPersistentDataContainer().has(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING))
+            .filter(e -> e.getPersistentDataContainer().get(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING).equals(tag))
+            .findAny();
+
+        if (optional.isEmpty()) return null;
+
+        return optional.get();
+    }
+
+    public List<Display> getAllDisplays() {
+        if (!isExist()) return Collections.emptyList();
+
+        return entity.getPassengers().stream()
+            .filter(e -> e instanceof Display)
+            .map(e -> (Display) e)
+            .toList();
+    }
+
+    public List<Display> getAllDisplaysByTag(String tag) {
+        if (!isExist()) return Collections.emptyList();
+
+        return entity.getPassengers().stream()
+            .filter(e -> e instanceof Display)
+            .map(e -> (Display) e)
+            .filter(e -> e.getPersistentDataContainer().has(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING))
+            .filter(e -> e.getPersistentDataContainer().get(DisplayBuilder.DISPLAY_TAG_KEY, PersistentDataType.STRING).equals(tag))
+            .toList();
+    }
+
+    public CustomEntityBehavior getBehavior() {
+        return behavior;
+    }
+
+    @Nullable
+    public static CustomEntity fromEntity(Entity entity) {
+        if (!entity.getPersistentDataContainer().has(ENTITY_KEY)) return null;
+
+        String tag = entity.getPersistentDataContainer().get(ENTITY_KEY, PersistentDataType.STRING);
+
+        CustomEntity customEntity = CustomEntity.getRegisteredEntities().get(tag).clone();
+        customEntity.entity = entity;
+
+        Optional<Interaction> optionalInteraction = entity.getPassengers().stream().filter(e -> e instanceof Interaction).map(e -> (Interaction) e).findAny();
+
+        if (optionalInteraction.isEmpty()) {
+            Interaction hitbox = entity.getLocation().getWorld().spawn(entity.getLocation(), Interaction.class);
+            entity.addPassenger(hitbox);
+
+            customEntity.hitbox = hitbox;
+        } else
+            customEntity.hitbox = optionalInteraction.get();
+
+        if (entity.getPassengers().size() < customEntity.displays.size()) {
+            for (Entity e : entity.getPassengers())
+                if (!(e instanceof Display)) {
+                    entity.removePassenger(e);
+
+                    e.remove();
+                }
+
+            entity.removePassenger(customEntity.hitbox);
+
+            for (DisplayBuilder builder : customEntity.displays)
+                entity.addPassenger(builder.get(entity.getLocation()));
+        }
+
+        return customEntity;
+    }
+
+    public String getTag() {
+        return tag;
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    public Interaction getHitbox() {
+        return hitbox;
+    }
+
+    private boolean isExist() {
+        return entity != null && !entity.isEmpty() && !entity.isDead() && !entity.isValid();
+    }
+
+    public static HashMap<String, CustomEntity> getRegisteredEntities() {
+        return registeredEntities;
+    }
+
+    @Override
+    public CustomEntity clone() {
+        return new CustomEntity(tag, basedOn, hitboxSize, behavior, show, displays, loot);
+    }
+
+    public void remove(boolean useLoot) {
+        if (hitbox != null) hitbox.remove();
+
+        if (useLoot)
+            for (ItemStack item : loot.getLoot())
+                entity.getWorld().dropItemNaturally(entity.getLocation(), item);
+
+        if (entity != null) {
+            for (Entity e : entity.getPassengers()) e.remove();
+
+            entity.remove();
+        }
+    }
+}
diff --git a/src/main/java/org/ospaindustries/entity/CustomEntityBehavior.java b/src/main/java/org/ospaindustries/entity/CustomEntityBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed31a1841d2fa7bddd774157c51c53a58d303e9b
--- /dev/null
+++ b/src/main/java/org/ospaindustries/entity/CustomEntityBehavior.java
@@ -0,0 +1,16 @@
+package org.ospaindustries.entity;
+
+import io.papermc.paper.event.player.PrePlayerAttackEntityEvent;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.event.entity.EntityDeathEvent;
+import org.bukkit.event.player.PlayerInteractAtEntityEvent;
+
+public interface CustomEntityBehavior {
+
+    default void tick(CustomEntity entity) {}
+    default void death(EntityDeathEvent event) {}
+    default void damageHitbox(PrePlayerAttackEntityEvent event) {}
+    default void damageEntity(EntityDamageEvent event) {}
+    default void interactionAtHitBox(PlayerInteractAtEntityEvent event, CustomEntity entity) {}
+    default void interactionAtEntity(PlayerInteractAtEntityEvent event) {}
+}
diff --git a/src/main/java/org/ospaindustries/entity/CustomEntityBuilder.java b/src/main/java/org/ospaindustries/entity/CustomEntityBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d5f986fb0d1bbc6f32b28db8fd0edfb4fabd59d
--- /dev/null
+++ b/src/main/java/org/ospaindustries/entity/CustomEntityBuilder.java
@@ -0,0 +1,78 @@
+package org.ospaindustries.entity;
+
+import org.bukkit.entity.EntityType;
+import org.bukkit.inventory.ItemStack;
+import org.joml.Vector2f;
+import org.ospaindustries.block.CustomBlock;
+import org.ospaindustries.utils.CustomLoot;
+import org.ospaindustries.utils.DisplayBuilder;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class CustomEntityBuilder {
+    private String tag;
+    private EntityType baseOn;
+    private final ArrayList<DisplayBuilder> displays = new ArrayList<>();
+    private CustomEntityBehavior behavior;
+    private boolean showBasedEntity = false;
+    private Vector2f hitbox = new Vector2f(1, 1);
+    private CustomLoot loot = Collections::emptyList;
+
+    public CustomEntityBuilder(String tag, EntityType baseOn) {
+        this.tag = tag;
+        this.baseOn = baseOn;
+    }
+
+    public void setTag(String tag) {
+        this.tag = tag;
+    }
+
+    public void setEntity(EntityType baseOn) {
+        this.baseOn = baseOn;
+    }
+
+    public CustomEntityBuilder addDisplay(DisplayBuilder displayBuilder) {
+        displays.add(displayBuilder);
+
+        return this;
+    }
+
+    public CustomEntityBuilder setBehavior(CustomEntityBehavior behavior) {
+        this.behavior = behavior;
+
+        return this;
+    }
+
+    public CustomEntityBuilder setBasedEntityVisibility(boolean value) {
+        showBasedEntity = value;
+
+        return this;
+     }
+
+     public CustomEntityBuilder setHitBoxSize(Vector2f vector) {
+        hitbox = vector;
+
+        return this;
+    }
+
+    public CustomEntityBuilder setHitBoxSize(float width, float height) {
+        hitbox = new Vector2f(width, height);
+
+        return this;
+    }
+
+    public void setLoot(CustomLoot loot) {
+        this.loot = loot;
+    }
+
+    public void register() {
+        CustomEntity entity = new CustomEntity(tag, baseOn.getEntityClass(), hitbox, behavior, showBasedEntity, displays, loot);
+
+        if (CustomEntity.getRegisteredEntities().containsKey(tag))
+            throw new RuntimeException("Can't register entity with tag \"" + tag + "\", this entity is already registered.");
+
+        CustomEntity.getRegisteredEntities().put(tag, entity);
+    }
+}
diff --git a/src/main/java/org/ospaindustries/item/CustomItem.java b/src/main/java/org/ospaindustries/item/CustomItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..19aed90401b91a27a7f343a07cd6d22e2f18923b
--- /dev/null
+++ b/src/main/java/org/ospaindustries/item/CustomItem.java
@@ -0,0 +1,119 @@
+package org.ospaindustries.item;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemFlag;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class CustomItem extends ItemStack {
+
+    public static NamespacedKey DICE_CORE_CUSTOM_ITEM_KEY = new NamespacedKey("dice_core", "custom_item_key");
+    private static final HashMap<String, CustomItem> registeredItems = new HashMap<>();
+    private final String itemTag;
+    private final boolean isBlockItem;
+    private final CustomItemBehavior behavior;
+
+    CustomItem(String name, Material material, String itemTag, int customModelData, ArrayList<String> lore, ArrayList<ItemFlag> flags, HashMap<NamespacedKey, String> stringTags, HashMap<NamespacedKey, Integer> integerTags, HashMap<NamespacedKey, Double> doubleTags, HashMap<NamespacedKey, Boolean> booleanTags, HashMap<Attribute, AttributeModifier> attributes, CustomItemBehavior behavior, boolean isBlockItem) {
+        this.itemTag = itemTag;
+        this.behavior = behavior;
+        this.isBlockItem = isBlockItem;
+
+        setType(material);
+
+        ItemMeta meta = getItemMeta();
+        meta.setDisplayName(name);
+        meta.setCustomModelData(customModelData);
+        meta.setLore(lore);
+        meta.getPersistentDataContainer().set(CustomItem.DICE_CORE_CUSTOM_ITEM_KEY, PersistentDataType.STRING, itemTag);
+
+        meta.setDisplayName(ChatColor.RESET + meta.getDisplayName());
+
+        for(ItemFlag flag: flags){
+            meta.addItemFlags(flag);
+        }
+
+        for (Attribute attribute: attributes.keySet())
+            meta.addAttributeModifier(attribute, attributes.get(attribute));
+
+        for (NamespacedKey key: stringTags.keySet())
+            meta.getPersistentDataContainer().set(key, PersistentDataType.STRING, stringTags.get(key));
+
+        for (NamespacedKey key: integerTags.keySet())
+            meta.getPersistentDataContainer().set(key, PersistentDataType.INTEGER, integerTags.get(key));
+
+        for (NamespacedKey key: doubleTags.keySet())
+            meta.getPersistentDataContainer().set(key, PersistentDataType.DOUBLE, doubleTags.get(key));
+
+        for (NamespacedKey key: booleanTags.keySet())
+            meta.getPersistentDataContainer().set(key, PersistentDataType.BOOLEAN, booleanTags.get(key));
+
+        setItemMeta(meta);
+        setAmount(1);
+    }
+
+    public String getItemTag() {
+        return itemTag;
+    }
+
+    public CustomItemBehavior getBehavior(){
+        return behavior;
+    }
+    public boolean isBlockItem() {
+        return isBlockItem;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+
+        if (!(obj instanceof CustomItem stack))
+            return false;
+
+        return getAmount() == stack.getAmount() && isSimilar(stack);
+    }
+
+    @Override
+    public boolean isSimilar(@Nullable ItemStack obj) {
+        if (this == obj)
+            return true;
+
+        if (!(obj instanceof CustomItem))
+            return false;
+
+        return getItemTag().equals(this.itemTag);
+    }
+
+    public static HashMap<String, CustomItem> getRegisteredItems() {
+        return registeredItems;
+    }
+
+    @Override
+    public @NotNull CustomItem clone() {
+        CustomItem itemStack = (CustomItem) super.clone();
+
+        if (getItemMeta() != null) {
+            itemStack.setItemMeta(getItemMeta());
+        }
+
+        if (getData() != null) {
+            itemStack.setData(getData());
+        }
+
+        return itemStack;
+    }
+}
diff --git a/src/main/java/org/ospaindustries/item/CustomItemBehavior.java b/src/main/java/org/ospaindustries/item/CustomItemBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..c08f1c76dc3845649f12c58b0548be7a6133ac17
--- /dev/null
+++ b/src/main/java/org/ospaindustries/item/CustomItemBehavior.java
@@ -0,0 +1,16 @@
+package org.ospaindustries.item;
+
+import org.bukkit.event.entity.EntityPickupItemEvent;
+import org.bukkit.event.inventory.InventoryClickEvent;
+import org.bukkit.event.player.*;
+import org.bukkit.inventory.Inventory;
+
+public interface CustomItemBehavior {
+
+    default void onInteract(PlayerInteractEvent e){}
+    default void onInteractAtEntity(PlayerInteractAtEntityEvent e){}
+    default void onInventoryClickWithCustomItem(InventoryClickEvent e){}
+    default void onInventoryClickAtCustomItem(InventoryClickEvent e){}
+    default void onDropItem(PlayerDropItemEvent e){}
+    default void onPickup(EntityPickupItemEvent e){}
+}
diff --git a/src/main/java/org/ospaindustries/item/CustomItemBuilder.java b/src/main/java/org/ospaindustries/item/CustomItemBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..854cbe13589d500b10abffe6392e6e291433129e
--- /dev/null
+++ b/src/main/java/org/ospaindustries/item/CustomItemBuilder.java
@@ -0,0 +1,164 @@
+package org.ospaindustries.item;
+
+import net.kyori.adventure.text.Component;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.inventory.ItemFlag;
+import org.checkerframework.checker.units.qual.A;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+public class CustomItemBuilder {
+
+    private String displayName;
+    private Component displayComponent;
+    private Material material;
+    private String tag;
+    private int customModelData;
+    private CustomItemBehavior behavior;
+    private final ArrayList<String> lore = new ArrayList<>();
+    private final ArrayList<ItemFlag> flags = new ArrayList<>();
+    private final HashMap<NamespacedKey, String> stringTags = new HashMap<>();
+    private final HashMap<NamespacedKey, Integer> integerTags = new HashMap<>();
+    private final HashMap<NamespacedKey, Double> doubleTags = new HashMap<>();
+    private final HashMap<NamespacedKey, Boolean> booleanTags = new HashMap<>();
+    private final HashMap<Attribute, AttributeModifier> attributes = new HashMap<>();
+    private boolean isBlockItem = false;
+    private int knockbackBonus = 0;
+    private boolean isProjectile = false;
+
+    public CustomItemBuilder(String tag, Material material, String displayName) {
+        this.tag = tag;
+        this.material = material;
+        this.displayName = displayName;
+    }
+
+    public CustomItemBuilder(String tag, Material material, Component displayComponent) {
+        this.tag = tag;
+        this.material = material;
+        this.displayComponent = displayComponent;
+    }
+
+    public CustomItemBuilder(String tag, Material material) {
+        this.tag = tag;
+        this.material = material;
+    }
+
+    public void register() {
+        NamespacedKey key = new NamespacedKey("dice_core", tag);
+
+        CustomItem item = new CustomItem(displayName, material, tag, customModelData, lore, flags, stringTags, integerTags, doubleTags, booleanTags, attributes, behavior, isBlockItem);
+
+        if (CustomItem.getRegisteredItems().containsKey(key))
+            throw new RuntimeException("Can't register item with tag \"" + tag + "\", this item is already registered.");
+
+        CustomItem.getRegisteredItems().put(tag, item);
+    }
+
+    public CustomItemBuilder setTag(String tag) {
+        this.tag = tag;
+
+        return this;
+    }
+
+    public CustomItemBuilder setMaterial(Material material) {
+        this.material = material;
+
+        return this;
+    }
+
+    public CustomItemBuilder setDisplayName(String displayName) {
+        this.displayName = displayName;
+
+        return this;
+    }
+
+    public CustomItemBuilder setCustomModelData(int customModelData) {
+        this.customModelData = customModelData;
+
+        return this;
+    }
+
+    public CustomItemBuilder setCustomItemBehavior(CustomItemBehavior behavior){
+        this.behavior = behavior;
+
+        return this;
+    }
+
+    public CustomItemBuilder setBlockItem(boolean blockItem) {
+        isBlockItem = blockItem;
+
+        return this;
+    }
+
+    public CustomItemBuilder addLore(String lorePart) {
+        lore.add(lorePart);
+
+        return this;
+    }
+
+    public CustomItemBuilder addLore(String... lorePart) {
+        lore.addAll(Arrays.stream(lorePart).toList());
+
+        return this;
+    }
+
+    public CustomItemBuilder addLore(List<String> lorePart) {
+        lore.addAll(lorePart);
+
+        return this;
+    }
+
+    public CustomItemBuilder addStringTag(NamespacedKey key, String tag){
+        stringTags.put(key, tag);
+
+        return this;
+    }
+
+    public CustomItemBuilder addIntegerTag(NamespacedKey key, int tag){
+        integerTags.put(key, tag);
+
+        return this;
+    }
+
+    public CustomItemBuilder addDoubleTag(NamespacedKey key, double tag){
+        doubleTags.put(key, tag);
+
+        return this;
+    }
+
+    public CustomItemBuilder addBooleanTag(NamespacedKey key, boolean tag){
+        booleanTags.put(key, tag);
+
+        return this;
+    }
+
+    public CustomItemBuilder addFlag(ItemFlag flag){
+        flags.add(flag);
+
+        return this;
+    }
+
+    public CustomItemBuilder addFlags(ItemFlag... flag){
+        flags.addAll(Arrays.stream(flag).toList());
+
+        return this;
+    }
+
+    public CustomItemBuilder addAttribute(Attribute attribute, AttributeModifier modifier) {
+        attributes.put(attribute, modifier);
+
+        return this;
+    }
+
+    public void setProjectile(boolean projectile) {
+        isProjectile = projectile;
+    }
+}
diff --git a/src/main/java/org/ospaindustries/utils/BreakBlockRunnable.java b/src/main/java/org/ospaindustries/utils/BreakBlockRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..f890815278883b99c52e501d17c8decf70c11d89
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/BreakBlockRunnable.java
@@ -0,0 +1,92 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.Damageable;
+import org.bukkit.scheduler.BukkitRunnable;
+import org.ospaindustries.block.CustomBlock;
+
+import java.util.HashMap;
+
+public class BreakBlockRunnable extends BukkitRunnable {
+
+    public static HashMap<Location, BreakBlockRunnable> breakBlockRunnables = new HashMap<>();
+
+    private final CustomBlock block;
+    private final Player player;
+
+    public BreakBlockRunnable(CustomBlock block, Player player) {
+        this.block = block;
+        this.player = player;
+
+        if (block.getBlock() == null) return;
+
+        breakBlockRunnables.put(block.getBlock().getLocation(), this);
+    }
+
+    private InstrumentMaterial getMaterial(ItemStack itemStack) {
+        String prefix = itemStack.getType().name().split("_")[0];
+        InstrumentMaterial material;
+
+        try {
+            material = InstrumentMaterial.valueOf(prefix);
+        } catch (IllegalArgumentException e) {
+            material = InstrumentMaterial.AIR;
+        }
+
+        return material;
+    }
+
+    private InstrumentType getType(ItemStack itemStack) {
+        InstrumentType type = null;
+
+        for (InstrumentType t : InstrumentType.values())
+            if (itemStack.getType().name().toLowerCase().contains(t.name().toLowerCase())) {
+                type = t;
+
+                break;
+            }
+
+        if (type == null) type = InstrumentType.HAND;
+
+        return type;
+    }
+
+    private int getDamage() {
+        ItemStack playerHand = player.getInventory().getItem(EquipmentSlot.HAND);
+        InstrumentMaterial material = getMaterial(playerHand);
+        InstrumentType type = getType(playerHand);
+
+        if (block.getInstrumentType() != type) return 1;
+
+        return material.getEfficiency();
+    }
+
+    @Override
+    public void run() {
+        block.setDurability(block.getDurability() - getDamage());
+        block.spawnDamageParticle();
+
+        if (block.getDurability() >= 0) return;
+
+        ItemStack stack = player.getInventory().getItem(EquipmentSlot.HAND);
+
+        breakBlockRunnables.remove(block.getBlock().getLocation());
+        this.cancel();
+
+        block.spawnBreakParticle();
+
+        boolean dropLoot = getMaterial(stack).ordinal() < block.getInstrumentMaterial().ordinal() || getType(stack) != block.getInstrumentType();
+
+        block.breakBlock(dropLoot, player);
+
+        if (stack.getItemMeta() instanceof Damageable) {
+            org.bukkit.entity.Damageable damageable = (org.bukkit.entity.Damageable) stack.getItemMeta();
+
+            damageable.damage(1);
+        }
+    }
+}
diff --git a/src/main/java/org/ospaindustries/utils/CustomLoot.java b/src/main/java/org/ospaindustries/utils/CustomLoot.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bed950fb24e22db8b9f8797f973bd31506a127f
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/CustomLoot.java
@@ -0,0 +1,11 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.inventory.ItemStack;
+
+import java.util.List;
+
+public interface CustomLoot {
+
+    List<ItemStack> getLoot();
+
+}
diff --git a/src/main/java/org/ospaindustries/utils/DisplayBuilder.java b/src/main/java/org/ospaindustries/utils/DisplayBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a1c6a63c61c71f45afa5d731aed894aa4ce9d89
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/DisplayBuilder.java
@@ -0,0 +1,11 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.Display;
+
+public interface DisplayBuilder {
+    NamespacedKey DISPLAY_TAG_KEY = new NamespacedKey("dice_core", "display_tag_key");
+
+    Display get(Location location);
+}
diff --git a/src/main/java/org/ospaindustries/utils/InstrumentMaterial.java b/src/main/java/org/ospaindustries/utils/InstrumentMaterial.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8c2952d3d9445eda95219ea1d0848e55cdb4585
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/InstrumentMaterial.java
@@ -0,0 +1,23 @@
+package org.ospaindustries.utils;
+
+import org.bukkit.Material;
+
+public enum InstrumentMaterial {
+    AIR(1),
+    WOODEN(2),
+    STONE(4),
+    GOLDEN(12),
+    IRON(6),
+    DIAMOND(8),
+    NETHERITE(10);
+
+    private final int efficiency;
+
+    InstrumentMaterial(int efficiency) {
+        this.efficiency = efficiency;
+    }
+
+    public int getEfficiency() {
+        return efficiency;
+    }
+}
diff --git a/src/main/java/org/ospaindustries/utils/InstrumentType.java b/src/main/java/org/ospaindustries/utils/InstrumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a92f812e66a26b499fc212c7d5039ea272d6fbf
--- /dev/null
+++ b/src/main/java/org/ospaindustries/utils/InstrumentType.java
@@ -0,0 +1,11 @@
+package org.ospaindustries.utils;
+
+public enum InstrumentType {
+    HAND,
+    PICKAXE,
+    AXE,
+    SWORD,
+    HOE,
+    SHOVEL,
+    SHEARS
+}
